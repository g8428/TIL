# -*- coding: utf-8 -*-
"""0215_deeplearning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13gSbFQSb_VYOgw2G0NKOq76TUWqf-oG2
"""

import numpy as np

def AND(x1, x2):
    w1, w2, theta = 1.0, 1.0, 1.4

    temp = x1*w1 + x2*w2

    if temp <= theta:
        return 0
    else:
        return 1

data = [(0, 0), (1, 0), (0, 1), (1, 1)]
for datum in data:
    y = AND(datum[0], datum[1])
    print(f"{datum} -> {y}" )

def AND(x1, x2):
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])
    b = -0.7
    # temp = np.sum(x*w) + b
    temp = np.dot(x, w) + b
    if temp <= 0:
        return 0
    else:
        return 1

data = [(0, 0), (1, 0), (0, 1), (1, 1)]
for datum in data:
    y = AND(datum[0], datum[1])
    print(f"{datum} -> {y}" )

def NAND(x1, x2):
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])
    b = -0.7
    # temp = np.sum(x*w) + b
    temp = np.dot(x, w) + b
    if temp > 0:
        return 0
    else:
        return 1

data = [(0, 0), (1, 0), (0, 1), (1, 1)]
for datum in data:
    y = NAND(datum[0], datum[1])
    print(f"{datum} -> {y}" )

def OR(x1, x2):
    x = np.array([x1, x2])
    w = np.array([1.0, 1.0])
    b = -0.4
    # temp = np.sum(x*w) + b
    temp = np.dot(x, w) + b
    if temp <= 0:
        return 0
    else:
        return 1

data = [(0, 0), (1, 0), (0, 1), (1, 1)]
for datum in data:
    y = OR(datum[0], datum[1])
    print(f"{datum} -> {y}" )

def XOR(x1, x2):
    s1 = NAND(x1, x2)
    s2 = OR(x1, x2)
    y = AND(s1, s2)
    return y

data = [(0, 0), (1, 0), (0, 1), (1, 1)]
for datum in data:
    y = XOR(datum[0], datum[1])
    print(f"{datum} -> {y}" )

def sigmoid(x):
    return 1 / (1 + np.exp(-x))

x = np.array([-1.0, 1.0, 2.0])
sigmoid(x)

def init_network():
    network = {}
    network['w1'] = np.array([[0.1, 0.3, 0.5],[0.2, 0.4, 0.6]])
    network['b1'] = np.array([0.1, 0.2, 0.3])
    network['w2'] = np.array([[0.1, 0.4], [0.2, 0.5], [0.3, 0.6]])
    network['b2'] = np.array([0.1, 0.2])
    network['w3'] = np.array([[0.1, 0.3], [0.2, 0.4]])
    network['b3'] = np.array([0.1, 0.2])

    return network


def forward(network, x):
    W1, W2, W3 = network['w1'], network['w2'], network['w3']
    b1, b2, b3 = network['b1'], network['b2'], network['b3']

    a1 = np.dot(x, W1) + b1
    z1 = sigmoid(a1)
    a2 = np.dot(z1, W2) + b2
    z2 = sigmoid(a2)
    a3 = np.dot(z2, W3) + b3
    y = a3

    return y

network = init_network()
print(network['w1'].shape[0])
x = np.array([1.0, 0.5])
y = forward(network, x)
print(y)

def softmax(x):
    exp_x = np.exp(x)
    sum_exp_x = sum(exp_x)
    y = exp_x / sum_exp_x

    return y

print(softmax([1, 2, 0]))

import pickle
def load_mnist(normalize=True, flatten=True, one_hot_label=False):
    def _change_one_hot_label(X):
        T = np.zeros((X.size, 10))
        for idx, row in enumerate(T):
            row[X[idx]] = 1

        return T


    with open('/content/drive/MyDrive/2021 K 디지털 - 멀티/공유폴더/실습 폴더/mnist.pkl', 'rb') as f:
        dataset = pickle.load(f)

    if normalize:
        for key in ('train_img', 'test_img'):
            dataset[key] = dataset[key].astype(np.float32)
            dataset[key] /= 255.0

    if one_hot_label:
        dataset['train_label'] = _change_one_hot_label(dataset['train_label'])

    if not flatten:
        for key in ('train_img', 'test_img'):
            dataset[key] = dataset[key].reshape(-1, 1, 28, 28)

    return (dataset['train_img'], dataset['train_label']),  (dataset['test_img'], dataset['test_label'])

"""# 새 섹션"""

(x_train, y_train), (x_test, y_test) = load_mnist(normalize=True, flatten=True, one_hot_label=False)

import pickle
with open('/content/drive/MyDrive/2021 K 디지털 - 멀티/공유폴더/실습 폴더/mnist.pkl', 'rb') as f:
    dataset = pickle.load(f)
    print(dataset.keys())

dataset['train_img'].shape

dataset['train_img'][0].shape

dataset['train_label'][0]

import numpy as np

for key in ('train_img', 'test_img'):
    dataset[key] = dataset[key].astype(np.float32)
    dataset[key] /= 255.0

dataset['train_label'] = _change_one_hot_label(dataset['train_label'])

def _change_one_hot_label(X):
    T = np.zeros((X.size, 10))
    for idx, row in enumerate(T):
        row[X[idx]] = 1

    return T

dataset['train_label'].shape

dataset['train_label'][1]

dataset['train_img'].reshape(-1, 1, 28, 28)[0]

import matplotlib.pyplot as plt

def displayData(X, Y):
    fig, ax = plt.subplots(nrows=10, ncols=10, figsize=(15, 15))
    fig.suptitle("Display randomly images of the training data set")

    for i in range(10):
        for j in range(10):
            ind = np.random.randint(X.shape[0])
            tmp = X[ind, :].reshape(28, 28)
            ax[i, j].set_title("label : {}".format(Y[ind]))
            ax[i, j].imshow(tmp, cmap='gray_r')
            plt.setp(ax[i, j].get_xticklabels(), visible=True)
            plt.setp(ax[i, j].get_yticklabels(), visible=True)
    
    fig.subplots_adjust(hspace=0.5, wspace=0.5)

displayData(x_train, y_train)

def init_network():
    with open("/content/drive/MyDrive/2021 K 디지털 - 멀티/공유폴더/실습 폴더/sample_weight.pkl", 'rb') as f:
        network = pickle.load(f)
    
    return network


def predict(network, x):
    W1, W2, W3 = network['W1'], network['W2'], network['W3']
    b1, b2, b3 = network['b1'], network['b2'], network['b3'] 

    a1 = np.dot(x, W1) + b1
    z1 = sigmoid(a1)

    a2 = np.dot(z1, W2) + b2
    z2 = sigmoid(a2)

    a3 = np.dot(z2, W3) + b3
    y = softmax(a3)

    return y

model = init_network()

model.keys()

model['W1'].shape

model['b1'].shape

model['W2'].shape

model['b2'].shape

model['W3'].shape

model['b3'].shape

x_test.shape

accuracy_cnt = 0
for i in range(len(x_test)):
    y = predict(model, x_test[i])
    p = np.argmax(y)
    if p == y_test[i]:
        accuracy_cnt += 1

print("Accuracy : {}".format(accuracy_cnt/len(x_test)))

